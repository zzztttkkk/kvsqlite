import re
from typing import TypedDict
import typing

if typing.TYPE_CHECKING:
    from io import TextIOBase


class Method(TypedDict):
    name: str
    args: str
    returns: str | None


multi_line_args_and_returns = re.compile(r"(?P<args>.*?)\)\s+(?P<returns>.*?)\s+{")


def read_methods(fp: str, typename: str) -> list[Method]:
    methods: list[Method] = []
    lb = "{"
    one_line_method_regexp = re.compile(
        rf"func\s*\(\w+\s*{typename}\s*\)\s*(?P<name>[A-Z]\w*)\((?P<args>.*?)\)(?P<returns>.*?)\{lb}"
    )
    multi_line_method_regexp = re.compile(
        rf"func\s*\(\w+\s*{typename}\s*\)\s*(?P<name>[A-Z]\w*)\("
    )

    with open(fp, encoding="utf8") as f:
        current_method: Method | None = None
        while True:
            line = f.readline()
            if not line:
                break
            line = line.strip()
            if not line:
                continue

            if current_method is None:
                if not line.startswith("func"):
                    continue
                if line.endswith("{"):
                    match = one_line_method_regexp.match(line)
                    if match is None:
                        continue
                    methods.append(
                        {
                            "name": match.group("name").strip(),
                            "args": match.group("args").strip(),
                            "returns": match.group("returns").strip(),
                        }
                    )
                    continue
                else:
                    match = multi_line_method_regexp.match(line)
                    if match is None:
                        continue

                    current_method = {
                        "name": match.group("name").strip(),
                        "args": "",
                        "returns": None,
                    }
                    continue

            current_method["args"] = current_method["args"] + f" {line}"
            if line.endswith("{"):
                methods.append(current_method)
                current_method = None
                continue

        for method in methods:
            if method["returns"] is None:
                match = multi_line_args_and_returns.match(method["args"])
                if match is None:
                    raise ValueError(
                        f"can not split args and returns for method {method['name']}"
                    )

                args = match.group("args").strip()
                returns = match.group("returns").strip()
                if args.endswith(","):
                    args = args[:-1]

                unb = False
                if returns.startswith("(") and returns.endswith(")"):
                    returns = returns[1:-1].strip()
                    unb = True

                if returns.endswith(","):
                    returns = returns[:-1]

                if unb:
                    returns = f"({returns})"

                method["args"] = args
                method["returns"] = returns

        return methods


def gen_onetype(
    f: "TextIOBase", name: str, args: str, argv: str, fp: str, typename: str
):
    methods = read_methods(fp, typename)
    head = f"""type {typename}WithCtx struct{{
    {typename}
    ctx context.Context
}}

func (tx TxWithCtx) {name}({args}) {typename}WithCtx {{
return {typename}WithCtx{{
    {typename}: tx.tx.{name}({argv}),
    ctx: tx.ctx,
}}
}}
"""
    f.write(head)

    for method in methods:
        args = method["args"]
        if not args.startswith("ctx context.Context"):
            raise ValueError(
                f"{fp} method {method['name']}'s first args, is not `ctx context.Context`"
            )

        args = args[len("ctx context.Context") :].strip()
        if args.startswith(","):
            args = args[1:].strip()

        argv = ""
        if args != "":
            argvtmp: list[str] = []
            for arg in args.split(","):
                parts = arg.strip().split(" ")
                if len(parts) != 2:
                    raise ValueError(f"{fp} method {method['name']}'s ")
                argname, argtype = parts[0], parts[1]
                if argtype.startswith("..."):
                    argvtmp.append(f"{argname}...")
                else:
                    argvtmp.append(argname)
            argv = f" , {', '.join(argvtmp)}"

        method = f"""func (handle {typename}WithCtx) {method["name"]} ({args}) {method["returns"]} {{
    return handle.{typename}.{method["name"]}(handle.ctx{argv})  
}}
"""
        f.write(method)


with open("with_ctx_impl.go", mode="w+", encoding="utf-8") as f:
    f.truncate(0)
    f.write("""// Code generated by ./gen.py; DO NOT EDIT
package kvsqlite

import (
    "context"
    "database/sql"
    "iter"
)
            
""")
    gen_onetype(f, "String", "", "", "string.go", "_StringHandle")
    gen_onetype(f, "Hash", "key string", "key", "hash.go", "_HashHandle")
    gen_onetype(f, "List", "key string", "key", "list.go", "_ListHandle")
